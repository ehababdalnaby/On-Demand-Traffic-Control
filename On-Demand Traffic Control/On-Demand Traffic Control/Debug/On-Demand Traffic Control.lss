
On-Demand Traffic Control.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000002e2  00000000  00000000  00000054  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000000  00800060  00800060  00000336  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .comment      00000030  00000000  00000000  00000336  2**0
                  CONTENTS, READONLY
  3 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000368  2**2
                  CONTENTS, READONLY
  4 .debug_aranges 00000058  00000000  00000000  000003a4  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   000009a4  00000000  00000000  000003fc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000600  00000000  00000000  00000da0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000004d5  00000000  00000000  000013a0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000078  00000000  00000000  00001878  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000403  00000000  00000000  000018f0  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000005f2  00000000  00000000  00001cf3  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000038  00000000  00000000  000022e5  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
   8:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
   c:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  10:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  14:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  18:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  1c:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  20:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  24:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  28:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  2c:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  30:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  34:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  38:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  3c:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  40:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  44:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  48:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  4c:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>
  50:	0c 94 34 00 	jmp	0x68	; 0x68 <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d8 e0       	ldi	r29, 0x08	; 8
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61
  60:	0e 94 36 00 	call	0x6c	; 0x6c <main>
  64:	0c 94 6f 01 	jmp	0x2de	; 0x2de <_exit>

00000068 <__bad_interrupt>:
  68:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000006c <main>:

#include "./MCAL/Dio driver/DIO.h"

int main(void)
{
	DIO_pinInit(PA0,Output);
  6c:	61 e0       	ldi	r22, 0x01	; 1
  6e:	80 e0       	ldi	r24, 0x00	; 0
  70:	0e 94 3f 00 	call	0x7e	; 0x7e <DIO_pinInit>
	while (1)
	{
		DIO_pinWrite(PA0,Low);
  74:	60 e0       	ldi	r22, 0x00	; 0
  76:	80 e0       	ldi	r24, 0x00	; 0
  78:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <DIO_pinWrite>
  7c:	fb cf       	rjmp	.-10     	; 0x74 <main+0x8>

0000007e <DIO_pinInit>:

EN_pinErro_t DIO_pinInit(EN_pinNum_t pinNum,EN_pinDirection_t pinDirection)
{
	EN_pinErro_t error = OK;
	//check if the pin is located in port A
	if (pinNum <= PA7)
  7e:	88 30       	cpi	r24, 0x08	; 8
  80:	08 f5       	brcc	.+66     	; 0xc4 <DIO_pinInit+0x46>
	{
		if (pinDirection == Output)
  82:	61 30       	cpi	r22, 0x01	; 1
  84:	71 f4       	brne	.+28     	; 0xa2 <DIO_pinInit+0x24>
		{
			setBit(DDRA,pinNum);
  86:	4a b3       	in	r20, 0x1a	; 26
  88:	21 e0       	ldi	r18, 0x01	; 1
  8a:	30 e0       	ldi	r19, 0x00	; 0
  8c:	b9 01       	movw	r22, r18
  8e:	02 c0       	rjmp	.+4      	; 0x94 <DIO_pinInit+0x16>
  90:	66 0f       	add	r22, r22
  92:	77 1f       	adc	r23, r23
  94:	8a 95       	dec	r24
  96:	e2 f7       	brpl	.-8      	; 0x90 <DIO_pinInit+0x12>
  98:	cb 01       	movw	r24, r22
  9a:	84 2b       	or	r24, r20
  9c:	8a bb       	out	0x1a, r24	; 26



EN_pinErro_t DIO_pinInit(EN_pinNum_t pinNum,EN_pinDirection_t pinDirection)
{
	EN_pinErro_t error = OK;
  9e:	80 e0       	ldi	r24, 0x00	; 0
  a0:	08 95       	ret
	{
		if (pinDirection == Output)
		{
			setBit(DDRA,pinNum);
		}
		else if (pinDirection == Input)
  a2:	61 11       	cpse	r22, r1
  a4:	7b c0       	rjmp	.+246    	; 0x19c <DIO_pinInit+0x11e>
		{
			clrBit(DDRA,pinNum);
  a6:	4a b3       	in	r20, 0x1a	; 26
  a8:	21 e0       	ldi	r18, 0x01	; 1
  aa:	30 e0       	ldi	r19, 0x00	; 0
  ac:	b9 01       	movw	r22, r18
  ae:	02 c0       	rjmp	.+4      	; 0xb4 <DIO_pinInit+0x36>
  b0:	66 0f       	add	r22, r22
  b2:	77 1f       	adc	r23, r23
  b4:	8a 95       	dec	r24
  b6:	e2 f7       	brpl	.-8      	; 0xb0 <DIO_pinInit+0x32>
  b8:	cb 01       	movw	r24, r22
  ba:	80 95       	com	r24
  bc:	84 23       	and	r24, r20
  be:	8a bb       	out	0x1a, r24	; 26



EN_pinErro_t DIO_pinInit(EN_pinNum_t pinNum,EN_pinDirection_t pinDirection)
{
	EN_pinErro_t error = OK;
  c0:	80 e0       	ldi	r24, 0x00	; 0
  c2:	08 95       	ret
		{
			error = WRONG_PIN_DIR;
		}
	}
	//check if the pin is located in port B
	else if (pinNum <= PB7)
  c4:	80 31       	cpi	r24, 0x10	; 16
  c6:	10 f5       	brcc	.+68     	; 0x10c <DIO_pinInit+0x8e>
	{
		pinNum-=PORTB_OFFSET;
  c8:	88 50       	subi	r24, 0x08	; 8
		if (pinDirection == Output)
  ca:	61 30       	cpi	r22, 0x01	; 1
  cc:	71 f4       	brne	.+28     	; 0xea <DIO_pinInit+0x6c>
		{
			setBit(DDRB,pinNum);
  ce:	47 b3       	in	r20, 0x17	; 23
  d0:	21 e0       	ldi	r18, 0x01	; 1
  d2:	30 e0       	ldi	r19, 0x00	; 0
  d4:	b9 01       	movw	r22, r18
  d6:	02 c0       	rjmp	.+4      	; 0xdc <DIO_pinInit+0x5e>
  d8:	66 0f       	add	r22, r22
  da:	77 1f       	adc	r23, r23
  dc:	8a 95       	dec	r24
  de:	e2 f7       	brpl	.-8      	; 0xd8 <DIO_pinInit+0x5a>
  e0:	cb 01       	movw	r24, r22
  e2:	84 2b       	or	r24, r20
  e4:	87 bb       	out	0x17, r24	; 23



EN_pinErro_t DIO_pinInit(EN_pinNum_t pinNum,EN_pinDirection_t pinDirection)
{
	EN_pinErro_t error = OK;
  e6:	80 e0       	ldi	r24, 0x00	; 0
  e8:	08 95       	ret
		pinNum-=PORTB_OFFSET;
		if (pinDirection == Output)
		{
			setBit(DDRB,pinNum);
		}
		else if (pinDirection == Input)
  ea:	61 11       	cpse	r22, r1
  ec:	59 c0       	rjmp	.+178    	; 0x1a0 <DIO_pinInit+0x122>
		{
			clrBit(DDRB,pinNum);
  ee:	47 b3       	in	r20, 0x17	; 23
  f0:	21 e0       	ldi	r18, 0x01	; 1
  f2:	30 e0       	ldi	r19, 0x00	; 0
  f4:	b9 01       	movw	r22, r18
  f6:	02 c0       	rjmp	.+4      	; 0xfc <DIO_pinInit+0x7e>
  f8:	66 0f       	add	r22, r22
  fa:	77 1f       	adc	r23, r23
  fc:	8a 95       	dec	r24
  fe:	e2 f7       	brpl	.-8      	; 0xf8 <DIO_pinInit+0x7a>
 100:	cb 01       	movw	r24, r22
 102:	80 95       	com	r24
 104:	84 23       	and	r24, r20
 106:	87 bb       	out	0x17, r24	; 23



EN_pinErro_t DIO_pinInit(EN_pinNum_t pinNum,EN_pinDirection_t pinDirection)
{
	EN_pinErro_t error = OK;
 108:	80 e0       	ldi	r24, 0x00	; 0
 10a:	08 95       	ret
		{
			error = WRONG_PIN_DIR;
		}
	}
	//check if the pin is located in port C
	else if (pinNum <= PC7)
 10c:	88 31       	cpi	r24, 0x18	; 24
 10e:	10 f5       	brcc	.+68     	; 0x154 <DIO_pinInit+0xd6>
	{
		pinNum-=PORTC_OFFSET;
 110:	80 51       	subi	r24, 0x10	; 16
		if (pinDirection == Output)
 112:	61 30       	cpi	r22, 0x01	; 1
 114:	71 f4       	brne	.+28     	; 0x132 <DIO_pinInit+0xb4>
		{
			setBit(DDRC,pinNum);
 116:	44 b3       	in	r20, 0x14	; 20
 118:	21 e0       	ldi	r18, 0x01	; 1
 11a:	30 e0       	ldi	r19, 0x00	; 0
 11c:	b9 01       	movw	r22, r18
 11e:	02 c0       	rjmp	.+4      	; 0x124 <DIO_pinInit+0xa6>
 120:	66 0f       	add	r22, r22
 122:	77 1f       	adc	r23, r23
 124:	8a 95       	dec	r24
 126:	e2 f7       	brpl	.-8      	; 0x120 <DIO_pinInit+0xa2>
 128:	cb 01       	movw	r24, r22
 12a:	84 2b       	or	r24, r20
 12c:	84 bb       	out	0x14, r24	; 20



EN_pinErro_t DIO_pinInit(EN_pinNum_t pinNum,EN_pinDirection_t pinDirection)
{
	EN_pinErro_t error = OK;
 12e:	80 e0       	ldi	r24, 0x00	; 0
 130:	08 95       	ret
		pinNum-=PORTC_OFFSET;
		if (pinDirection == Output)
		{
			setBit(DDRC,pinNum);
		}
		else if (pinDirection == Input)
 132:	61 11       	cpse	r22, r1
 134:	37 c0       	rjmp	.+110    	; 0x1a4 <DIO_pinInit+0x126>
		{
			clrBit(DDRC,pinNum);
 136:	44 b3       	in	r20, 0x14	; 20
 138:	21 e0       	ldi	r18, 0x01	; 1
 13a:	30 e0       	ldi	r19, 0x00	; 0
 13c:	b9 01       	movw	r22, r18
 13e:	02 c0       	rjmp	.+4      	; 0x144 <DIO_pinInit+0xc6>
 140:	66 0f       	add	r22, r22
 142:	77 1f       	adc	r23, r23
 144:	8a 95       	dec	r24
 146:	e2 f7       	brpl	.-8      	; 0x140 <DIO_pinInit+0xc2>
 148:	cb 01       	movw	r24, r22
 14a:	80 95       	com	r24
 14c:	84 23       	and	r24, r20
 14e:	84 bb       	out	0x14, r24	; 20



EN_pinErro_t DIO_pinInit(EN_pinNum_t pinNum,EN_pinDirection_t pinDirection)
{
	EN_pinErro_t error = OK;
 150:	80 e0       	ldi	r24, 0x00	; 0
 152:	08 95       	ret
		{
			error = WRONG_PIN_DIR;
		}
	}
	//check if the pin is located in port D
	else if (pinNum <= PD7)
 154:	80 32       	cpi	r24, 0x20	; 32
 156:	40 f5       	brcc	.+80     	; 0x1a8 <DIO_pinInit+0x12a>
	{
		pinNum-=PORTD_OFFSET;
 158:	88 51       	subi	r24, 0x18	; 24
		if (pinDirection == Output)
 15a:	61 30       	cpi	r22, 0x01	; 1
 15c:	71 f4       	brne	.+28     	; 0x17a <DIO_pinInit+0xfc>
		{
			setBit(DDRD,pinNum);
 15e:	41 b3       	in	r20, 0x11	; 17
 160:	21 e0       	ldi	r18, 0x01	; 1
 162:	30 e0       	ldi	r19, 0x00	; 0
 164:	b9 01       	movw	r22, r18
 166:	02 c0       	rjmp	.+4      	; 0x16c <DIO_pinInit+0xee>
 168:	66 0f       	add	r22, r22
 16a:	77 1f       	adc	r23, r23
 16c:	8a 95       	dec	r24
 16e:	e2 f7       	brpl	.-8      	; 0x168 <DIO_pinInit+0xea>
 170:	cb 01       	movw	r24, r22
 172:	84 2b       	or	r24, r20
 174:	81 bb       	out	0x11, r24	; 17



EN_pinErro_t DIO_pinInit(EN_pinNum_t pinNum,EN_pinDirection_t pinDirection)
{
	EN_pinErro_t error = OK;
 176:	80 e0       	ldi	r24, 0x00	; 0
 178:	08 95       	ret
		pinNum-=PORTD_OFFSET;
		if (pinDirection == Output)
		{
			setBit(DDRD,pinNum);
		}
		else if (pinDirection == Input)
 17a:	61 11       	cpse	r22, r1
 17c:	17 c0       	rjmp	.+46     	; 0x1ac <DIO_pinInit+0x12e>
		{
			clrBit(DDRD,pinNum);
 17e:	41 b3       	in	r20, 0x11	; 17
 180:	21 e0       	ldi	r18, 0x01	; 1
 182:	30 e0       	ldi	r19, 0x00	; 0
 184:	b9 01       	movw	r22, r18
 186:	02 c0       	rjmp	.+4      	; 0x18c <DIO_pinInit+0x10e>
 188:	66 0f       	add	r22, r22
 18a:	77 1f       	adc	r23, r23
 18c:	8a 95       	dec	r24
 18e:	e2 f7       	brpl	.-8      	; 0x188 <DIO_pinInit+0x10a>
 190:	cb 01       	movw	r24, r22
 192:	80 95       	com	r24
 194:	84 23       	and	r24, r20
 196:	81 bb       	out	0x11, r24	; 17



EN_pinErro_t DIO_pinInit(EN_pinNum_t pinNum,EN_pinDirection_t pinDirection)
{
	EN_pinErro_t error = OK;
 198:	80 e0       	ldi	r24, 0x00	; 0
 19a:	08 95       	ret
		{
			clrBit(DDRA,pinNum);
		}
		else
		{
			error = WRONG_PIN_DIR;
 19c:	82 e0       	ldi	r24, 0x02	; 2
 19e:	08 95       	ret
		{
			clrBit(DDRB,pinNum);
		}
		else
		{
			error = WRONG_PIN_DIR;
 1a0:	82 e0       	ldi	r24, 0x02	; 2
 1a2:	08 95       	ret
		{
			clrBit(DDRC,pinNum);
		}
		else
		{
			error = WRONG_PIN_DIR;
 1a4:	82 e0       	ldi	r24, 0x02	; 2
 1a6:	08 95       	ret
		}
	}
	//if the pinNum is wrong
	else
	{
		error = WRONG_PIN_NUM;
 1a8:	81 e0       	ldi	r24, 0x01	; 1
 1aa:	08 95       	ret
		{
			clrBit(DDRD,pinNum);
		}
		else
		{
			error = WRONG_PIN_DIR;
 1ac:	82 e0       	ldi	r24, 0x02	; 2
	else
	{
		error = WRONG_PIN_NUM;
	}
	return error;
}
 1ae:	08 95       	ret

000001b0 <DIO_pinWrite>:
/********************************************************************************************************************************************************/
EN_pinErro_t DIO_pinWrite(EN_pinNum_t pinNum,EN_pinState_t pinState)
{
	EN_pinErro_t error = OK;
	//check if the pin is located in port A
	if (pinNum <= PA7)
 1b0:	88 30       	cpi	r24, 0x08	; 8
 1b2:	08 f5       	brcc	.+66     	; 0x1f6 <DIO_pinWrite+0x46>
	{
		if (pinState == High)
 1b4:	61 30       	cpi	r22, 0x01	; 1
 1b6:	71 f4       	brne	.+28     	; 0x1d4 <DIO_pinWrite+0x24>
		{
			setBit(PORTA,pinNum);
 1b8:	4b b3       	in	r20, 0x1b	; 27
 1ba:	21 e0       	ldi	r18, 0x01	; 1
 1bc:	30 e0       	ldi	r19, 0x00	; 0
 1be:	b9 01       	movw	r22, r18
 1c0:	02 c0       	rjmp	.+4      	; 0x1c6 <DIO_pinWrite+0x16>
 1c2:	66 0f       	add	r22, r22
 1c4:	77 1f       	adc	r23, r23
 1c6:	8a 95       	dec	r24
 1c8:	e2 f7       	brpl	.-8      	; 0x1c2 <DIO_pinWrite+0x12>
 1ca:	cb 01       	movw	r24, r22
 1cc:	84 2b       	or	r24, r20
 1ce:	8b bb       	out	0x1b, r24	; 27
	return error;
}
/********************************************************************************************************************************************************/
EN_pinErro_t DIO_pinWrite(EN_pinNum_t pinNum,EN_pinState_t pinState)
{
	EN_pinErro_t error = OK;
 1d0:	80 e0       	ldi	r24, 0x00	; 0
 1d2:	08 95       	ret
	{
		if (pinState == High)
		{
			setBit(PORTA,pinNum);
		}
		else if (pinState == Low)
 1d4:	61 11       	cpse	r22, r1
 1d6:	79 c0       	rjmp	.+242    	; 0x2ca <DIO_pinWrite+0x11a>
		{
			clrBit(PORTA,pinNum);
 1d8:	4b b3       	in	r20, 0x1b	; 27
 1da:	21 e0       	ldi	r18, 0x01	; 1
 1dc:	30 e0       	ldi	r19, 0x00	; 0
 1de:	b9 01       	movw	r22, r18
 1e0:	02 c0       	rjmp	.+4      	; 0x1e6 <DIO_pinWrite+0x36>
 1e2:	66 0f       	add	r22, r22
 1e4:	77 1f       	adc	r23, r23
 1e6:	8a 95       	dec	r24
 1e8:	e2 f7       	brpl	.-8      	; 0x1e2 <DIO_pinWrite+0x32>
 1ea:	cb 01       	movw	r24, r22
 1ec:	80 95       	com	r24
 1ee:	84 23       	and	r24, r20
 1f0:	8b bb       	out	0x1b, r24	; 27
	return error;
}
/********************************************************************************************************************************************************/
EN_pinErro_t DIO_pinWrite(EN_pinNum_t pinNum,EN_pinState_t pinState)
{
	EN_pinErro_t error = OK;
 1f2:	80 e0       	ldi	r24, 0x00	; 0
 1f4:	08 95       	ret
		{
			error = WRONG_PIN_STATE;
		}
	}
	//check if the pin is located in port B
	else if (pinNum <= PB7)
 1f6:	80 31       	cpi	r24, 0x10	; 16
 1f8:	10 f5       	brcc	.+68     	; 0x23e <DIO_pinWrite+0x8e>
	{
		pinNum-=PORTB_OFFSET;
 1fa:	88 50       	subi	r24, 0x08	; 8
		if (pinState == High)
 1fc:	61 30       	cpi	r22, 0x01	; 1
 1fe:	71 f4       	brne	.+28     	; 0x21c <DIO_pinWrite+0x6c>
		{
			setBit(PORTB,pinNum);
 200:	48 b3       	in	r20, 0x18	; 24
 202:	21 e0       	ldi	r18, 0x01	; 1
 204:	30 e0       	ldi	r19, 0x00	; 0
 206:	b9 01       	movw	r22, r18
 208:	02 c0       	rjmp	.+4      	; 0x20e <DIO_pinWrite+0x5e>
 20a:	66 0f       	add	r22, r22
 20c:	77 1f       	adc	r23, r23
 20e:	8a 95       	dec	r24
 210:	e2 f7       	brpl	.-8      	; 0x20a <DIO_pinWrite+0x5a>
 212:	cb 01       	movw	r24, r22
 214:	84 2b       	or	r24, r20
 216:	88 bb       	out	0x18, r24	; 24
	return error;
}
/********************************************************************************************************************************************************/
EN_pinErro_t DIO_pinWrite(EN_pinNum_t pinNum,EN_pinState_t pinState)
{
	EN_pinErro_t error = OK;
 218:	80 e0       	ldi	r24, 0x00	; 0
 21a:	08 95       	ret
		pinNum-=PORTB_OFFSET;
		if (pinState == High)
		{
			setBit(PORTB,pinNum);
		}
		else if (pinState == Low)
 21c:	61 11       	cpse	r22, r1
 21e:	57 c0       	rjmp	.+174    	; 0x2ce <DIO_pinWrite+0x11e>
		{
			clrBit(PORTB,pinNum);
 220:	48 b3       	in	r20, 0x18	; 24
 222:	21 e0       	ldi	r18, 0x01	; 1
 224:	30 e0       	ldi	r19, 0x00	; 0
 226:	b9 01       	movw	r22, r18
 228:	02 c0       	rjmp	.+4      	; 0x22e <DIO_pinWrite+0x7e>
 22a:	66 0f       	add	r22, r22
 22c:	77 1f       	adc	r23, r23
 22e:	8a 95       	dec	r24
 230:	e2 f7       	brpl	.-8      	; 0x22a <DIO_pinWrite+0x7a>
 232:	cb 01       	movw	r24, r22
 234:	80 95       	com	r24
 236:	84 23       	and	r24, r20
 238:	88 bb       	out	0x18, r24	; 24
	return error;
}
/********************************************************************************************************************************************************/
EN_pinErro_t DIO_pinWrite(EN_pinNum_t pinNum,EN_pinState_t pinState)
{
	EN_pinErro_t error = OK;
 23a:	80 e0       	ldi	r24, 0x00	; 0
 23c:	08 95       	ret
		{
			error = WRONG_PIN_STATE;
		}
	}
	//check if the pin is located in port C
	else if (pinNum <= PC7)
 23e:	88 31       	cpi	r24, 0x18	; 24
 240:	08 f5       	brcc	.+66     	; 0x284 <DIO_pinWrite+0xd4>
	{
		if (pinState == High)
 242:	61 30       	cpi	r22, 0x01	; 1
 244:	71 f4       	brne	.+28     	; 0x262 <DIO_pinWrite+0xb2>
		{
			setBit(PORTC,pinNum);
 246:	45 b3       	in	r20, 0x15	; 21
 248:	21 e0       	ldi	r18, 0x01	; 1
 24a:	30 e0       	ldi	r19, 0x00	; 0
 24c:	b9 01       	movw	r22, r18
 24e:	02 c0       	rjmp	.+4      	; 0x254 <DIO_pinWrite+0xa4>
 250:	66 0f       	add	r22, r22
 252:	77 1f       	adc	r23, r23
 254:	8a 95       	dec	r24
 256:	e2 f7       	brpl	.-8      	; 0x250 <DIO_pinWrite+0xa0>
 258:	cb 01       	movw	r24, r22
 25a:	84 2b       	or	r24, r20
 25c:	85 bb       	out	0x15, r24	; 21
	return error;
}
/********************************************************************************************************************************************************/
EN_pinErro_t DIO_pinWrite(EN_pinNum_t pinNum,EN_pinState_t pinState)
{
	EN_pinErro_t error = OK;
 25e:	80 e0       	ldi	r24, 0x00	; 0
 260:	08 95       	ret
	{
		if (pinState == High)
		{
			setBit(PORTC,pinNum);
		}
		else if (pinState == Low)
 262:	61 11       	cpse	r22, r1
 264:	36 c0       	rjmp	.+108    	; 0x2d2 <DIO_pinWrite+0x122>
		{
			clrBit(PORTC,pinNum);
 266:	45 b3       	in	r20, 0x15	; 21
 268:	21 e0       	ldi	r18, 0x01	; 1
 26a:	30 e0       	ldi	r19, 0x00	; 0
 26c:	b9 01       	movw	r22, r18
 26e:	02 c0       	rjmp	.+4      	; 0x274 <DIO_pinWrite+0xc4>
 270:	66 0f       	add	r22, r22
 272:	77 1f       	adc	r23, r23
 274:	8a 95       	dec	r24
 276:	e2 f7       	brpl	.-8      	; 0x270 <DIO_pinWrite+0xc0>
 278:	cb 01       	movw	r24, r22
 27a:	80 95       	com	r24
 27c:	84 23       	and	r24, r20
 27e:	85 bb       	out	0x15, r24	; 21
	return error;
}
/********************************************************************************************************************************************************/
EN_pinErro_t DIO_pinWrite(EN_pinNum_t pinNum,EN_pinState_t pinState)
{
	EN_pinErro_t error = OK;
 280:	80 e0       	ldi	r24, 0x00	; 0
 282:	08 95       	ret
		{
			error = WRONG_PIN_STATE;
		}
	}
	//check if the pin is located in port D
	else if (pinNum <= PD7)
 284:	80 32       	cpi	r24, 0x20	; 32
 286:	38 f5       	brcc	.+78     	; 0x2d6 <DIO_pinWrite+0x126>
	{
		if (pinState == High)
 288:	61 30       	cpi	r22, 0x01	; 1
 28a:	71 f4       	brne	.+28     	; 0x2a8 <DIO_pinWrite+0xf8>
		{
			setBit(PORTD,pinNum);
 28c:	42 b3       	in	r20, 0x12	; 18
 28e:	21 e0       	ldi	r18, 0x01	; 1
 290:	30 e0       	ldi	r19, 0x00	; 0
 292:	b9 01       	movw	r22, r18
 294:	02 c0       	rjmp	.+4      	; 0x29a <DIO_pinWrite+0xea>
 296:	66 0f       	add	r22, r22
 298:	77 1f       	adc	r23, r23
 29a:	8a 95       	dec	r24
 29c:	e2 f7       	brpl	.-8      	; 0x296 <DIO_pinWrite+0xe6>
 29e:	cb 01       	movw	r24, r22
 2a0:	84 2b       	or	r24, r20
 2a2:	82 bb       	out	0x12, r24	; 18
	return error;
}
/********************************************************************************************************************************************************/
EN_pinErro_t DIO_pinWrite(EN_pinNum_t pinNum,EN_pinState_t pinState)
{
	EN_pinErro_t error = OK;
 2a4:	80 e0       	ldi	r24, 0x00	; 0
 2a6:	08 95       	ret
	{
		if (pinState == High)
		{
			setBit(PORTD,pinNum);
		}
		else if (pinState == Low)
 2a8:	61 11       	cpse	r22, r1
 2aa:	17 c0       	rjmp	.+46     	; 0x2da <DIO_pinWrite+0x12a>
		{
			clrBit(PORTD,pinNum);
 2ac:	42 b3       	in	r20, 0x12	; 18
 2ae:	21 e0       	ldi	r18, 0x01	; 1
 2b0:	30 e0       	ldi	r19, 0x00	; 0
 2b2:	b9 01       	movw	r22, r18
 2b4:	02 c0       	rjmp	.+4      	; 0x2ba <DIO_pinWrite+0x10a>
 2b6:	66 0f       	add	r22, r22
 2b8:	77 1f       	adc	r23, r23
 2ba:	8a 95       	dec	r24
 2bc:	e2 f7       	brpl	.-8      	; 0x2b6 <DIO_pinWrite+0x106>
 2be:	cb 01       	movw	r24, r22
 2c0:	80 95       	com	r24
 2c2:	84 23       	and	r24, r20
 2c4:	82 bb       	out	0x12, r24	; 18
	return error;
}
/********************************************************************************************************************************************************/
EN_pinErro_t DIO_pinWrite(EN_pinNum_t pinNum,EN_pinState_t pinState)
{
	EN_pinErro_t error = OK;
 2c6:	80 e0       	ldi	r24, 0x00	; 0
 2c8:	08 95       	ret
		{
			clrBit(PORTA,pinNum);
		}
		else
		{
			error = WRONG_PIN_STATE;
 2ca:	83 e0       	ldi	r24, 0x03	; 3
 2cc:	08 95       	ret
		{
			clrBit(PORTB,pinNum);
		}
		else
		{
			error = WRONG_PIN_STATE;
 2ce:	83 e0       	ldi	r24, 0x03	; 3
 2d0:	08 95       	ret
		{
			clrBit(PORTC,pinNum);
		}
		else
		{
			error = WRONG_PIN_STATE;
 2d2:	83 e0       	ldi	r24, 0x03	; 3
 2d4:	08 95       	ret
		}
	}
	//if the pinNum is wrong
	else
	{
		error = WRONG_PIN_NUM;
 2d6:	81 e0       	ldi	r24, 0x01	; 1
 2d8:	08 95       	ret
		{
			clrBit(PORTD,pinNum);
		}
		else
		{
			error = WRONG_PIN_STATE;
 2da:	83 e0       	ldi	r24, 0x03	; 3
	else
	{
		error = WRONG_PIN_NUM;
	}
	return error;
}
 2dc:	08 95       	ret

000002de <_exit>:
 2de:	f8 94       	cli

000002e0 <__stop_program>:
 2e0:	ff cf       	rjmp	.-2      	; 0x2e0 <__stop_program>
